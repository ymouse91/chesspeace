<!doctype html>
<html lang="fi">
<head>
<meta charset="utf-8" />
<!-- iOS: viewport-fit=cover on pakko safe-areaa varten -->
<!-- Huom: maximum-scale=1 + user-scalable=no est√§√§ zoomin (strict!) -->
<meta name="viewport"
      content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no,viewport-fit=cover">

<!-- PWA perus -->
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#f3f5f8">
<meta name="color-scheme" content="light dark">

<!-- iOS PWA -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="white">
<meta name="apple-mobile-web-app-title" content="Chess Peace">

<!-- Icons -->
<link rel="icon" href="icon192.png">
<link rel="apple-touch-icon" href="icon192.png">

<title>Chess Peace ‚Äì PC/iPad</title>
<style>
  :root{
    /* V√§ripaletti - el√§v√§mpi */
    --bg:#f8fafd;
    --bg-accent:#eef2f9;
    --panel:#ffffff;
    --ink:#1a2a4a;
    --ink-light:#6b7589;
    --line:#d0d8e8;
    --soft:#b8c5d8;

    /* Primary - sininen */
    --primary:#5b7cff;
    --primary-light:#7d96ff;
    --primary-dark:#3d5ace;

    /* Accent v√§rit */
    --success:#27d37c;
    --success-light:#5ae5a0;
    --warning:#ffa726;
    --danger:#ff5252;
    --info:#29b6f6;

    --cell: 76px;
    --gap: 6px;

    /* cover tints */
    --coverW:#e7eefc;
    --coverB:#efe9ff;

    /* anchors */
    --wbg:#ffffff;
    --bbg:#1a2a4a;
    --wfg:#000000;
    --bfg:#ffffff;

    --bad:#ff5252;
    --sel:#27d37c;
    --hint:#5ae5a0;

    --btn:#eef2f9;
    --btn2:#5b7cff;
    --btn-text:#1a2a4a;

    /* JS asettaa --vh */
    --vh: 1vh;

    /* safe area */
    --sat: env(safe-area-inset-top);
    --sar: env(safe-area-inset-right);
    --sab: env(safe-area-inset-bottom);
    --sal: env(safe-area-inset-left);

    color-scheme: light;
  }

  /* T√ÑRKE√Ñ: html-tausta est√§√§ valkoiset "nauhat" kuminauhassa */
  html{
    height: 100%;
    background: var(--bg);
    background-color: var(--bg);
  }

  body{
    margin: 0;
    height: 100%;
    min-height: calc(var(--vh) * 100);
    background: var(--bg);
    color: var(--ink);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    
    /* est√§ "sivun" scrollaus */
    overflow: hidden;
    overscroll-behavior: none;
    scroll-behavior: auto;

    /* iOS: nopeampi tuntuma */
    -webkit-text-size-adjust: 100%;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;

    /* Font rendering iOS:lla */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;

    /* Teksti-valinta pois (peleille kriittist√§) */
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }

  #app{
    position: fixed;
    inset: 0;
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: clamp(6px, 2vmin, 16px);
    padding: 0;
    overflow: hidden;
    background: linear-gradient(135deg, #f8fafd 0%, #f0f4fb 100%);
  }

  #topbar{
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    background: var(--panel);
    border-bottom: 1px solid var(--line);
    padding: max(8px, env(safe-area-inset-top)) 
             max(8px, env(safe-area-inset-right))
             10px
             max(8px, env(safe-area-inset-left));
    width: 100%;
    box-sizing: border-box;
    user-select: none;
    overflow-x: auto;
    overflow-y: hidden;
    box-shadow: 0 2px 8px rgba(27, 42, 74, 0.08);
    backdrop-filter: blur(10px);
  }
  #topbar .left{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
  }

  #main{
    display: grid;
    grid-template-columns: max-content 1fr;
    gap: 16px;
    align-items: start;
    padding: clamp(6px, 2vmin, 16px) 
             max(clamp(8px, 2vmin, 16px), env(safe-area-inset-right))
             clamp(6px, 2vmin, 16px)
             max(clamp(8px, 2vmin, 16px), env(safe-area-inset-left));
    min-height: 0;
    overflow: auto;
    -webkit-user-select: none;
    user-select: none;
  }

  #leftPane{
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:flex-start;
  }

  #boardWrap{
    background: var(--panel);
    border: 1px solid var(--line);
    padding: 12px;
    width: max-content;
    box-sizing: border-box;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(27, 42, 74, 0.08);
    transition: all 300ms ease;
  }

  #boardWrap:hover {
    box-shadow: 0 8px 24px rgba(27, 42, 74, 0.12);
  }

  footer#status{
    text-align: center;
    font-size: clamp(12px, 2vw, 16px);
    user-select: none;
    padding-bottom: max(8px, env(safe-area-inset-bottom));
    padding-left: max(8px, env(safe-area-inset-left));
    padding-right: max(8px, env(safe-area-inset-right));
    padding-top: 12px;
    width: 100%;
    box-sizing: border-box;
    background: var(--panel);
    border-top: 1px solid var(--line);
    box-shadow: 0 -2px 8px rgba(27, 42, 74, 0.06);
    color: var(--ink-light);
    font-weight: 500;
  }

  footer#status b {
    color: var(--ink);
    font-weight: 700;
  }

  select, button{ 
    font: inherit; 
    font-size: clamp(12px, 2.5vw, 16px);
    user-select: none;
    -webkit-user-select: none;
    -webkit-tap-highlight-color: transparent;
    outline: none;
    -webkit-appearance: none;
    appearance: none;
    box-shadow: none;
  }

  select{
    padding: clamp(6px, 1.5vw, 8px) clamp(8px, 2vw, 10px);
    border: 1px solid var(--line);
    border-radius: 8px;
    background: var(--panel);
    cursor: pointer;
    transition: all 200ms cubic-bezier(0.23, 1, 0.320, 1);
    color: var(--ink);
  }

  select:focus {
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(91, 124, 255, 0.1);
  }

  button{
    padding: clamp(6px, 1.5vw, 8px) clamp(10px, 2vw, 14px);
    border: none;
    border-radius: 8px;
    background: var(--btn);
    color: var(--ink);
    cursor: pointer;
    transition: all 200ms cubic-bezier(0.23, 1, 0.320, 1);
    font-weight: 500;
    box-shadow: 0 2px 4px rgba(27, 42, 74, 0.06);
    position: relative;
    overflow: hidden;
  }
  
  button::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 0;
    height: 0;
    border-radius: 50%;
    background: rgba(91, 124, 255, 0.1);
    transform: translate(-50%, -50%);
    transition: width 0.6s, height 0.6s;
    pointer-events: none;
  }
  
  button:active::before {
    width: 300px;
    height: 300px;
  }
  
  button:focus{
    outline: none;
    box-shadow: 0 4px 12px rgba(91, 124, 255, 0.2);
  }
  
  button:hover{ 
    background: var(--btn2);
    color: white;
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(91, 124, 255, 0.25);
  }

  button:active{
    transform: scale(0.98);
  }

  #board{
    display:grid;
    grid-template-columns:repeat(5, var(--cell));
    grid-template-rows:repeat(5, var(--cell));
    gap:var(--gap);
  }

  .cell{
    border: 1px solid var(--line);
    background: #fff;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation;
    box-sizing: border-box;
    overflow: hidden;
    transition: all 200ms ease;
  }

  .cell.coverW{ background: var(--coverW); }
  .cell.coverB{ background: var(--coverB); }

  .cell.coverW::after,
  .cell.coverB::after{
    content: "";
    position: absolute;
    inset: 0;
    outline: 2px solid #00000012;
    pointer-events: none;
  }

  .cell.anchorW{
    background: var(--wbg);
    color: var(--wfg);
    border: 2px solid #000;
    font-weight: 500;
    font-size: 45px;
    line-height: 1;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .cell.anchorB{
    background: var(--bbg);
    color: var(--bfg);
    border: 2px solid #000;
    font-weight: 200;
    font-size: 45px;
    line-height: 1;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .cell.fixed{
    box-shadow: inset 0 0 0 3px rgba(0, 0, 0, 0.1);
  }

  .cell.bad{
    outline: 4px solid var(--bad);
    outline-offset: -3px;
    animation: pulse-bad 1s ease-in-out infinite;
  }

  @keyframes pulse-bad {
    0%, 100% { outline-color: var(--bad); }
    50% { outline-color: rgba(255, 82, 82, 0.5); }
  }

  /* hinted (revealed) piece highlighting */
  .cell.hinted{

    box-shadow: inset 0 0 0 3px var(--success), 0 0 12px rgba(39, 211, 124, 0.3);
    animation: pulse-hint 1.5s ease-in-out infinite;
  }

  @keyframes pulse-hint {
    0%, 100% { box-shadow: inset 0 0 0 3px var(--success), 0 0 12px rgba(39, 211, 124, 0.3); }
    50% { box-shadow: inset 0 0 0 3px var(--success-light), 0 0 20px rgba(39, 211, 124, 0.5); }
  }

  /* right palette */
  #rightPane{
    flex:1;
    display:flex;
    flex-direction:column;
    gap:12px;
    min-width:360px;
  }

  #legend{
    background: var(--panel);
    border: 1px solid var(--line);
    padding: 12px;
    font-size: 14px;
    line-height: 1.35;
    width: 100%;
    max-width: calc(5 * 76px + 4 * 6px + 24px);
    box-sizing: border-box;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(27, 42, 74, 0.06);
    color: var(--ink-light);
  }

  #legend b {
    color: var(--ink);
    font-weight: 600;
  }

  #palette{
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
  }

  .col{
    background: var(--panel);
    border: 1px solid var(--line);
    padding: 12px;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(27, 42, 74, 0.06);
    transition: all 300ms ease;
  }

  .col:hover {
    box-shadow: 0 4px 12px rgba(27, 42, 74, 0.1);
    transform: translateY(-2px);
  }

  .col h3{
    margin: 0 0 10px 0;
    font-size: 14px;
    letter-spacing: 0.4px;
    text-transform: uppercase;

    color: var(--primary);
    font-weight: 900;
  }

  .pieceGrid{
    display:grid;
    grid-template-columns:1fr;
    gap:10px;
  }

  .piece{
    border: 1px solid var(--line);
    background: var(--panel);
    padding: 8px;
    cursor: pointer;
    display: inline-block;
    touch-action: manipulation;
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(27, 42, 74, 0.08);
    transition: all 200ms cubic-bezier(0.23, 1, 0.320, 1);
  }

  .piece:hover:not(.placed) {
    box-shadow: 0 4px 12px rgba(27, 42, 74, 0.15);
    transform: translateY(-2px);
    border-color: var(--primary);
  }

  .piece.selected{
    border: 2px solid var(--primary);
    background: linear-gradient(135deg, rgba(91, 124, 255, 0.05) 0%, rgba(91, 124, 255, 0.1) 100%);
    padding: 7px;
    box-shadow: 0 4px 16px rgba(91, 124, 255, 0.2), inset 0 0 0 2px var(--primary);
    animation: pulse-select 0.6s ease-in-out;
  }

  @keyframes pulse-select {
    0% { box-shadow: 0 4px 16px rgba(91, 124, 255, 0.2), inset 0 0 0 2px var(--primary); }
    50% { box-shadow: 0 6px 24px rgba(91, 124, 255, 0.3), inset 0 0 0 2px var(--primary-light); }
    100% { box-shadow: 0 4px 16px rgba(91, 124, 255, 0.2), inset 0 0 0 2px var(--primary); }
  }

  .piece.placed{
    opacity: 0.5;
    cursor: default;
    filter: grayscale(0.5);
  }

  .piece.placed:hover {
    box-shadow: 0 2px 6px rgba(27, 42, 74, 0.08);
    transform: none;
  }

  .pieceHeader{
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    margin-bottom: 6px;

  }

  .mini{
    display: grid;
    gap: 3px;
  }

  .t{
    width:24px;
    height:24px;
    background:#e6e6e6;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:16px;
    font-weight:400;
    border:1px solid #00000012;
    box-sizing:border-box;
  }

  .t.empty{ visibility:hidden; }

  .t.coverW{ background:var(--coverW); }
  .t.coverB{ background:var(--coverB); }

  .t.anchorW{
    background:var(--wbg);
    color:var(--wfg);
    border:2px solid #000;
  }
  .t.anchorB{
    background:var(--bbg);
    color:var(--bfg);
    border:2px solid #000;
  }

  .hintText{
  font-size:12px;

  margin-top:0;
  width:max-content;
  max-width:none;
}

  .mono{
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  }

  /* Pienet puhelimet ‚Äì korjauksia jos clamp ei riit√§ */
  @media (max-width: 360px) {
    body {
      font-size: 13px;
    }
    #app {
      gap: clamp(4px, 1vmin, 12px);
    }
  }

  /* Landscape-tila: pienempi pystyvali */
  @media (orientation: landscape) and (max-height: 600px) {
    #app {
      grid-template-rows: auto 1fr auto;
      gap: clamp(4px, 1vmin, 12px);
    }
    
    #topbar {
      padding: max(4px, env(safe-area-inset-top)) 
               max(6px, env(safe-area-inset-right))
               6px
               max(6px, env(safe-area-inset-left)) !important;
      gap: clamp(6px, 1.5vw, 10px);
    }

    #main {
      padding: clamp(4px, 1vmin, 8px)
               max(clamp(6px, 1vmin, 12px), env(safe-area-inset-right))
               clamp(4px, 1vmin, 8px)
               max(clamp(6px, 1vmin, 12px), env(safe-area-inset-left));
    }
    
    footer#status {
      padding: 4px max(6px, env(safe-area-inset-right))
               max(4px, env(safe-area-inset-bottom))
               max(6px, env(safe-area-inset-left));
      font-size: 11px;
    }
  }

  /* Tablet (iPad) ‚Äì varmistetaan hyv√§ spacing */
  @media (min-width: 768px) {
    #topbar {
      gap: clamp(12px, 3vw, 20px);
    }
    #main {
      gap: clamp(16px, 3vw, 24px);
    }
  }

  /* Suuret n√§yt√∂t (desktop preview) */
  @media (min-width: 1200px) {
    body {
      font-size: 16px;
    }
    #main {
      max-width: 1400px;
    }
  }

  /* K√§ytt√§j√§ haluaa v√§hemm√§n animaatioita */
  @media (prefers-reduced-motion: reduce){
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }
</style>
</head>

<body>
<div id="app">

  <header id="topbar">
    <div class="left">
	<h1 style="font-size: 24px">CHESS PEACE</h1>
      <label>
        Vaikeustaso:
        <select id="difficulty">
          <option value="starter">starter</option>
          <option value="junior" selected>junior</option>
          <option value="expert">expert</option>
          <option value="master">master</option>
          <option value="wizard">wizard</option>
        </select>
      </label>
      <button id="btnNew">Uusi pulma</button>
      <button id="btnHint">Vihje +1</button>
      <button id="btnLoadLocal">Lataa solutions.json</button>
      <input type="file" id="fileSolutions" accept=".json" style="display:none">
    </div>
  </header>

  <main id="main">
    <section id="leftPane">
      <div id="boardWrap">
        <div id="board" aria-label="5x5 pelilauta"></div>
      </div>

      <div id="legend">
        <b>Tavoite:</b> Asettele kaikki laatat alustalle niin, ett√§ valkeat shakkinappulat eiv√§t uhkaa mustia tai p√§invastoin.<br>
        Klikkaa palettipalaa: <b>valitse</b>. <br>Klikkaa samaa uudestaan: <b>kierr√§ 90¬∞</b>. <br>Klikkaa lautaa: <b>aseta</b>. <br>Klikkaa asetettua (ei-lukittua) palaa laudalla tai paletissa: <b>poista</b>.<br>
        <div id="loadInfo" class="mono" style="display:none">
        </div>

        <div class="hintText" style="display:none">
          Klikkaa palettipalaa: valitse. Klikkaa samaa uudestaan: kierr√§ 90¬∞. Klikkaa lautaa: aseta. Klikkaa asetettua (ei-lukittua) palaa laudalla: poista.<br>
          <b>S√§√§nt√∂:</b> valkoinen ei saa uhata mustaa eik√§ p√§invastoin. ‚ôï/‚ôñ/‚ôó blokkaus tapahtuu <b>vain nappuloilla</b> (ankkuriruudut).
        </div>
      </div>
    </section>

    <aside id="rightPane">
      <div id="palette">
        <div class="col">
          <h3>Valkoiset</h3>
          <div id="whiteCol" class="pieceGrid"></div>
        </div>
        <div class="col">
          <h3>Mustat</h3>
          <div id="blackCol" class="pieceGrid"></div>
        </div>
      </div>
    </aside>
  </main>

  <footer id="status">Valmis!</footer>

</div>


<script>
/* =========================
   CORE
========================= */
const SIZE = 5;

const boardEl = document.getElementById("board");
const whiteCol = document.getElementById("whiteCol");
const blackCol = document.getElementById("blackCol");
const elDiff  = document.getElementById("difficulty");
const elStatus = document.getElementById("status");
const elLoadInfo = document.getElementById("loadInfo");
const btnNew = document.getElementById("btnNew");
const btnHint = document.getElementById("btnHint");
const btnLoadLocal = document.getElementById("btnLoadLocal");
const fileSolutions = document.getElementById("fileSolutions");

let selectedPieceId = null;

// board[y][x] either null or { instId, kind:"cover"|"anchor", color:"W"|"B", type:"KQRBN", fixed:boolean, hinted:boolean }
let board = Array.from({length:SIZE},()=>Array(SIZE).fill(null));

// placed instances: instId -> { pieceId, cells:[{x,y,kind}], anchor:{x,y}, fixed:boolean }
const instances = new Map();
let instSeq = 1;

// loaded solutions: data.solutions[]
let SOLUTIONS = [];
let CURRENT_SOLUTION = null;

/* =========================
   CHESS SYMBOLS
========================= */
const SYM = {
  W: { K:"‚ôî", Q:"‚ôï", R:"‚ôñ", B:"‚ôó", N:"‚ôò" },
  B: { K:"‚ôö", Q:"‚ôõ", R:"‚ôú", B:"‚ôù", N:"‚ôû" }
};
function sym(color,type){ return (SYM[color] && SYM[color][type]) ? SYM[color][type] : "?"; }

/* =========================
   PIECES
   '-' = empty, 'X' = cover, anchor markers K/Q/T/L/R (T rook, L bishop, R knight marker)
========================= */
const PIECES = [
  // WHITE
  {id:"WK", color:"W", type:"K", name:"Kuningas", shape:[ ["K"] ]},
  {id:"WQ", color:"W", type:"Q", name:"Kuningatar", shape:[ ["X","X"], ["Q","-"] ]},
  {id:"WR", color:"W", type:"R", name:"Torni",     shape:[ ["X","T"] ]},
  {id:"WB", color:"W", type:"B", name:"L√§hetti",   shape:[ ["L","-"], ["X","X"] ]},
  {id:"WN", color:"W", type:"N", name:"Ratsu",     shape:[ ["X","-","-"], ["X","X","R"] ]},

  // BLACK
  {id:"BK", color:"B", type:"K", name:"Kuningas",  shape:[ ["K"] ]},
  {id:"BQ", color:"B", type:"Q", name:"Kuningatar",shape:[ ["X","X"], ["X","Q"] ]},
  {id:"BR", color:"B", type:"R", name:"Torni",     shape:[ ["X","T"] ]},
  {id:"BB", color:"B", type:"B", name:"L√§hetti",   shape:[ ["X","-"], ["X","L"] ]},
  {id:"BN", color:"B", type:"N", name:"Ratsu",     shape:[ ["R","X"] ]},
].map(p=>({ ...p, rot:0, placed:false, fixedPlaced:false, el:null }));

const PIECE_IDS = ["WK","WQ","WR","WB","WN","BK","BQ","BR","BB","BN"];
const ANCHOR_CHARS = new Set(["K","Q","T","L","R"]);

/* =========================
   DIFFICULTY REVEALS
   With your 52-solution file:
   master -> 2, wizard -> 1 (or 2 if needed)
========================= */
const REVEAL_COUNTS = {
  starter: 7,
  junior:  5,
  expert:  3,
  master:  2,
  wizard:  1
};
const UNIQUE_LEVELS = new Set(["master","wizard","expert","junior","starter"]);

/* =========================
   BOARD UI
========================= */
function buildBoard(){
  boardEl.innerHTML = "";
  for(let y=0;y<SIZE;y++){
    for(let x=0;x<SIZE;x++){
      const c = document.createElement("div");
      c.className = "cell";
      c.addEventListener("click", ()=> onBoardClick(x,y));
      boardEl.appendChild(c);
    }
  }
}
function cellEl(x,y){ return boardEl.children[y*SIZE + x]; }

function redrawBoard(){
  for(let y=0;y<SIZE;y++){
    for(let x=0;x<SIZE;x++){
      const el = cellEl(x,y);
      el.className = "cell";
      el.textContent = "";

      const v = board[y][x];
      if(!v) continue;

      if(v.kind === "cover"){
        el.classList.add(v.color==="W" ? "coverW" : "coverB");
      }else{
        el.classList.add(v.color==="W" ? "anchorW" : "anchorB");
        el.textContent = sym(v.color, v.type);
      }

      if(v.fixed) el.classList.add("fixed");
      if(v.hinted) el.classList.add("hinted");
    }
  }
}

/* =========================
   ROTATION (player placing)
========================= */

function maxRotDims(piece){
  let s = piece.shape;
  let maxH = s.length, maxW = s[0].length;
  for(let i=0;i<3;i++){
    s = rotate90(s);
    maxH = Math.max(maxH, s.length);
    maxW = Math.max(maxW, s[0].length);
  }
  return {maxH, maxW};
}
function rotate90(mat){
  const h = mat.length, w = mat[0].length;
  const out = [];
  for(let x=0;x<w;x++){
    const row = [];
    for(let y=h-1;y>=0;y--) row.push(mat[y][x]);
    out.push(row);
  }
  return out;
}
function rotatedShape(piece){
  let s = piece.shape;
  for(let i=0;i<piece.rot;i++) s = rotate90(s);
  return s;
}

/* =========================
   PALETTE UI
========================= */

function renderPalette(){
  whiteCol.innerHTML = "";
  blackCol.innerHTML = "";

  for(const p of PIECES){
    const el = document.createElement("div");
    el.className = "piece";
    p.el = el;

el.addEventListener("click", ()=>{
  if(p.fixedPlaced) return;  // Lukitut palat ei saa poistaa
  
  const canRotate = !(p.shape.length===1 && p.shape[0].length===1);
  
  if(selectedPieceId === p.id){
    // Sama pala klikattu uudelleen
    if(p.placed && !p.fixedPlaced){
      // POISTA LAATTA jos on asetettuna
      for(const instId of instances.keys()){
        const inst = instances.get(instId);
        if(inst && inst.pieceId === p.id){
          removeInstance(instId);
          break;
        }
      }
      redrawBoard();
      renderPalette();
      validateIfComplete();
    } else if(canRotate){
      // Kierr√§ jos EI asetettuna
      p.rot = (p.rot + 1) % 4;
      renderPalette();
    }
  }else{
    // Eri pala valittiin
    selectedPieceId = p.id;
    renderPalette();
  }
});

    if(selectedPieceId === p.id) el.classList.add("selected");
    if(p.placed || p.fixedPlaced) el.classList.add("placed");

    const header = document.createElement("div");
    header.className = "pieceHeader";
    const lock = p.fixedPlaced ? " üîí" : "";
    header.innerHTML = `<span><b>${p.name}</b></span><span style="font-size:20px">${sym(p.color,p.type)}</span><span style="font-size:20px"> ${lock}</span>`;
    el.appendChild(header);

    const mini = document.createElement("div");
    mini.className = "mini";

    const sh = rotatedShape(p);
    mini.style.gridTemplateColumns = `repeat(${sh[0].length}, 24px)`;
	mini.style.gridAutoRows = "24px";   // <-- T√ÑM√Ñ
    const md = maxRotDims(p);
    const tile = 24;
    const g = 3;
    mini.style.width = (md.maxW*tile + (md.maxW-1)*g) + "px";
    mini.style.height = (md.maxH*tile + (md.maxH-1)*g) + "px";

    for(let yy=0; yy<sh.length; yy++){
      for(let xx=0; xx<sh[0].length; xx++){
        const v = sh[yy][xx];
        const t = document.createElement("div");
        t.className = "t";

        if(v === "-"){
          t.classList.add("empty");
        }else{
          t.classList.add(p.color==="W" ? "coverW":"coverB");
          if(ANCHOR_CHARS.has(v)){
            t.classList.remove("coverW","coverB");
            t.classList.add(p.color==="W" ? "anchorW":"anchorB");
            t.textContent = sym(p.color, p.type);
          }
        }
        mini.appendChild(t);
      }
    }
    el.appendChild(mini);

    (p.color==="W" ? whiteCol : blackCol).appendChild(el);
  }
}

/* =========================
   PLACING / REMOVING
========================= */
function findPiece(id){ return PIECES.find(p=>p.id===id) || null; }

function anchorFromShape(shape){
  for(let y=0;y<shape.length;y++){
    for(let x=0;x<shape[0].length;x++){
      if(ANCHOR_CHARS.has(shape[y][x])) return {ax:x, ay:y};
    }
  }
  return {ax:0, ay:0};
}

function canPlaceAt(piece, boardX, boardY){
  const sh = rotatedShape(piece);
  const {ax, ay} = anchorFromShape(sh);

  for(let yy=0; yy<sh.length; yy++){
    for(let xx=0; xx<sh[0].length; xx++){
      const v = sh[yy][xx];
      if(v === "-") continue;

      const x = boardX + (xx-ax);
      const y = boardY + (yy-ay);

      if(x<0 || x>=SIZE || y<0 || y>=SIZE) return false;
      if(board[y][x] !== null) return false;
    }
  }
  return true;
}

function placePlayerAt(piece, boardX, boardY){
  const sh = rotatedShape(piece);
  const {ax, ay} = anchorFromShape(sh);

  const instId = "i" + (instSeq++);
  const cells = [];
  let anchor = null;

  for(let yy=0; yy<sh.length; yy++){
    for(let xx=0; xx<sh[0].length; xx++){
      const v = sh[yy][xx];
      if(v === "-") continue;

      const x = boardX + (xx-ax);
      const y = boardY + (yy-ay);

      const isAnchor = ANCHOR_CHARS.has(v);
      const kind = isAnchor ? "anchor" : "cover";

      board[y][x] = { instId, kind, color:piece.color, type:piece.type, fixed:false, hinted:false };
      cells.push({x,y,kind});
      if(isAnchor) anchor = {x,y};
    }
  }

  instances.set(instId, { pieceId:piece.id, cells, anchor, fixed:false });
  piece.placed = true;
}

function placeFixedFromSolution(pieceId, solPiece, isHinted=false){
  const piece = findPiece(pieceId);
  if(!piece) return false;

  const instId = "i" + (instSeq++);
  const cells = [];
  const ax = solPiece.anchor.x, ay = solPiece.anchor.y;

  for(const c of solPiece.cells){
    if(board[c.y][c.x] !== null) return false;
  }

  for(const c of solPiece.cells){
    const isAnchor = (c.x === ax && c.y === ay);
    const kind = isAnchor ? "anchor" : "cover";
    board[c.y][c.x] = { instId, kind, color:piece.color, type:piece.type, fixed:true, hinted:!!isHinted };
    cells.push({x:c.x,y:c.y,kind});
  }

  instances.set(instId, { pieceId:piece.id, cells, anchor:{x:ax,y:ay}, fixed:true });
  piece.fixedPlaced = true;
  return true;
}

function removeInstance(instId){
  const inst = instances.get(instId);
  if(!inst || inst.fixed) return;

  for(const c of inst.cells){
    board[c.y][c.x] = null;
  }
  instances.delete(instId);

  const p = findPiece(inst.pieceId);
  if(p) p.placed = false;
}

function onBoardClick(x,y){
  clearBadMarks();

  const v = board[y][x];

  if(v && !v.fixed){
    removeInstance(v.instId);
    redrawBoard();
    renderPalette();
    validateIfComplete();
    return;
  }
  if(v && v.fixed) return;

  if(!selectedPieceId) return;
  const p = findPiece(selectedPieceId);
  if(!p || p.placed || p.fixedPlaced) return;

  if(!canPlaceAt(p, x, y)) return;

  placePlayerAt(p, x, y);
  redrawBoard();
  renderPalette();
  validateIfComplete();
}

/* =========================
   VALIDATION (anchors-only blocking)
========================= */
function allPiecesPlaced(){ return PIECES.every(p => p.fixedPlaced || p.placed); }

function collectAnchors(){
  const out = [];
  for(let y=0;y<SIZE;y++){
    for(let x=0;x<SIZE;x++){
      const v = board[y][x];
      if(v && v.kind==="anchor"){
        out.push({x,y,color:v.color,type:v.type});
      }
    }
  }
  return out;
}

function clearBadMarks(){
  for(let y=0;y<SIZE;y++){
    for(let x=0;x<SIZE;x++){
      cellEl(x,y).classList.remove("bad");
    }
  }
}
function markBadAt(x,y){ cellEl(x,y).classList.add("bad"); }

function isAnchorOccupied(x,y){
  const v = board[y][x];
  return !!(v && v.kind==="anchor");
}

function attacks(a,b){
  const dx = b.x - a.x;
  const dy = b.y - a.y;
  const adx = Math.abs(dx);
  const ady = Math.abs(dy);

  if(a.type === "K"){
    return adx<=1 && ady<=1 && (adx+ady>0);
  }
  if(a.type === "N"){
    return (adx===2 && ady===1) || (adx===1 && ady===2);
  }

  let dirX = 0, dirY = 0;

  if(a.type === "R"){
    if(dx===0) dirY = Math.sign(dy);
    else if(dy===0) dirX = Math.sign(dx);
    else return false;
  }

  if(a.type === "B"){
    if(adx===ady){
      dirX = Math.sign(dx);
      dirY = Math.sign(dy);
    } else return false;
  }

  if(a.type === "Q"){
    if(dx===0) dirY = Math.sign(dy);
    else if(dy===0) dirX = Math.sign(dx);
    else if(adx===ady){
      dirX = Math.sign(dx);
      dirY = Math.sign(dy);
    } else return false;
  }

  let x = a.x + dirX;
  let y = a.y + dirY;

  while(x>=0 && x<SIZE && y>=0 && y<SIZE){
    if(x===b.x && y===b.y) return true;
    if(isAnchorOccupied(x,y)) return false; // blocked by ANY piece (anchor)
    x += dirX;
    y += dirY;
  }
  return false;
}

function validateIfComplete(){
  if(!allPiecesPlaced()){
    elStatus.textContent = "";
    return;
  }
  const anchors = collectAnchors();
  const bad = new Set();

  for(let i=0;i<anchors.length;i++){
    for(let j=0;j<anchors.length;j++){
      if(i===j) continue;
      const a = anchors[i], b = anchors[j];
      if(a.color === b.color) continue;
      if(attacks(a,b)){
        bad.add(a.x+","+a.y);
        bad.add(b.x+","+b.y);
      }
    }
  }

  for(const key of bad){
    const [x,y] = key.split(",").map(Number);
    markBadAt(x,y);
  }

  elStatus.textContent = (bad.size===0) ? "‚úì Laillinen asetelma" : "‚úó Uhkauskonflikti";
}

/* =========================
   SOLUTION LOADING
========================= */
async function loadSolutions(){
  const url = "solutions.json";
  try{
    const res = await fetch(url, {cache:"no-store"});
    if(!res.ok) throw new Error("HTTP "+res.status);
    const data = await res.json();

    if(!data || !Array.isArray(data.solutions)) throw new Error("JSON: puuttuu data.solutions[]");

    const out = [];
    for(const s of data.solutions){
      if(!s) continue;
      let ok = true;
      for(const id of PIECE_IDS){
        const p = s[id];
        if(!p || !p.anchor || !Array.isArray(p.cells) || !Number.isFinite(p.opt)) { ok=false; break; }
      }
      if(ok) out.push(s);
    }

    SOLUTIONS = out;
    elLoadInfo.textContent = `solutions.json ladattu: ${SOLUTIONS.length} ratkaisua (size=${data.size}, count=${data.count})`;
    return true;
  }catch(err){
    SOLUTIONS = [];
    elLoadInfo.textContent = `‚ö† Ei voitu ladata solutions.json: ${err.message} ‚Äî Avaa sivu http-palvelimelta (ei file://), tai k√§yt√§ "Lataa solutions.json" -nappia.`;
    return false;
  }
}

/* =========================
   PUZZLE PICKING (from existing solutions)
========================= */
function resetGameState(){
  board = Array.from({length:SIZE},()=>Array(SIZE).fill(null));
  instances.clear();
  instSeq = 1;

  for(const p of PIECES){
    p.rot = 0;
    p.placed = false;
    p.fixedPlaced = false;
  }
  selectedPieceId = null;
  clearBadMarks();
  elStatus.textContent = "";
}

function shuffle(a){
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

function countMatchingSolutions(givens){
  let n = 0;
  for(const s of SOLUTIONS){
    let ok = true;
    for(const id in givens){
      if(s[id].opt !== givens[id]) { ok=false; break; }
    }
    if(ok) n++;
  }
  return n;
}

function pickRandomSolution(){
  return SOLUTIONS[Math.floor(Math.random()*SOLUTIONS.length)];
}

function buildGivenSetForSolution(sol, level){
  const needUnique = UNIQUE_LEVELS.has(level);

  // helpoille tasoille pidet√§√§n kuninkaat mukana, muille ei pakkoa
  const mandatory = (level==="starter" || level==="junior" || level==="expert")
    ? ["WK","BK"]
    : [];

  const pool = PIECE_IDS.filter(id => !mandatory.includes(id));

  function tryWithK(k){
    const MAX_TRIES = 4000;
    for(let t=0;t<MAX_TRIES;t++){
      const pick = shuffle(pool.slice()).slice(0, Math.max(0, k - mandatory.length));
      const chosen = mandatory.concat(pick);

      const givens = {};
      for(const id of chosen) givens[id] = sol[id].opt;

      const cnt = countMatchingSolutions(givens);
      if(cnt===1) return {givens, matchCount: 1, k: chosen.length};
    }
    return null;
  }

  // wizard: 1 pala, jos ei uniikki -> 2 palaa
  if(level==="wizard"){
    return tryWithK(1) || tryWithK(2);
  }

  // master: 2 palaa (uniikki vaadittu)
  if(level==="master"){
    return tryWithK(2);
  }

  // muille tasoille: aloita target-m√§√§r√§st√§ ja kasvata kunnes l√∂ytyy yksik√§sitteinen
  const target = REVEAL_COUNTS[level] ?? 7;
  for(let k = target; k <= PIECE_IDS.length; k++){
    const result = tryWithK(k);
    if(result) return result;
  }
  return null;
}

function applyGivensToBoard(sol, givens){
  for(const id in givens){
    placeFixedFromSolution(id, sol[id], false);
  }
}

function startNewPuzzle(){
  if(SOLUTIONS.length===0){
    elStatus.textContent = "‚ö† Ratkaisuja ei ole ladattu.";
    return;
  }

  resetGameState();
  buildBoard();

  const level = elDiff.value;

  const MAX_SOL_TRIES = 300;
  let pickedSol = null;
  let pack = null;

  for(let t=0; t<MAX_SOL_TRIES; t++){
    const cand = pickRandomSolution();
    const candPack = buildGivenSetForSolution(cand, level);
    if(!candPack) continue;
    pickedSol = cand;
    pack = candPack;
    break;
  }

  if(!pickedSol || !pack){
    elStatus.textContent = "‚ö† Ei l√∂ytynyt kelvollista pulmaa t√§lle tasolle.";
    return;
  }

  CURRENT_SOLUTION = pickedSol;

  const {givens, matchCount} = pack;
  applyGivensToBoard(pickedSol, givens);

  // player pieces start at rot=0
  for(const p of PIECES){
    if(p.fixedPlaced) continue;
    p.rot = 0;
  }

  redrawBoard();
  renderPalette();
  validateIfComplete();

  const uniqTxt = UNIQUE_LEVELS.has(level) ? " (uniikki)" : "";
  elStatus.textContent = `Taso: ${level}${uniqTxt} ‚Äî paljastettu ${Object.keys(givens).length}/10 ‚Äî sopivia ratkaisuja: ${matchCount}`;
}

/* =========================
   HINT: reveal one correct piece (fixed + green)
========================= */
function revealOneCorrectPiece(){
  if(!CURRENT_SOLUTION){
    elStatus.textContent = "‚ö† Ei aktiivista pulmaa.";
    return;
  }

  const candidates = PIECE_IDS.filter(id=>{
    const p = findPiece(id);
    return p && !p.fixedPlaced && !p.placed;
  });

  if(candidates.length===0){
    elStatus.textContent = "‚úì Kaikki palat ovat jo laudalla.";
    return;
  }

  const shuffled = shuffle(candidates.slice());
  for(const id of shuffled){
    const solPiece = CURRENT_SOLUTION[id];

    let ok = true;
    for(const c of solPiece.cells){
      if(board[c.y][c.x] !== null){ ok=false; break; }
    }
    if(!ok) continue;

    placeFixedFromSolution(id, solPiece, true);
    redrawBoard();
    renderPalette();
    validateIfComplete();
    elStatus.textContent = "Vihje: yksi oikea pala paljastettu (vihre√§ll√§).";
    return;
  }

  elStatus.textContent = "‚ö† Vihjett√§ ei voi asettaa: lauta on ristiriidassa ratkaisun kanssa (poista jokin asettamasi pala).";
}

/* =========================
   INIT
========================= */
buildBoard();
renderPalette();

btnNew.addEventListener("click", startNewPuzzle);
btnHint.addEventListener("click", revealOneCorrectPiece);
elDiff.addEventListener("change", startNewPuzzle);

if(btnLoadLocal && fileSolutions){
  btnLoadLocal.addEventListener("click", ()=> fileSolutions.click());
  fileSolutions.addEventListener("change", async ()=>{
    const f = fileSolutions.files && fileSolutions.files[0];
    if(!f) return;
    try{
      const txt = await f.text();
      const data = JSON.parse(txt);
      if(!data || !Array.isArray(data.solutions)) throw new Error("Puuttuu solutions[]");

      const out = [];
      for(const s of data.solutions){
        if(!s) continue;
        let ok = true;
        for(const id of PIECE_IDS){
          const p = s[id];
          if(!p || !p.anchor || !Array.isArray(p.cells) || !Number.isFinite(p.opt)) { ok=false; break; }
        }
        if(ok) out.push(s);
      }

      SOLUTIONS = out;
      elLoadInfo.textContent = `Paikallinen tiedosto ladattu: ${SOLUTIONS.length} ratkaisua`;
      startNewPuzzle();
    }catch(e){
      elLoadInfo.textContent = `‚ö† Paikallisen tiedoston luku ep√§onnistui: ${e.message}`;
    }
  });
}
loadSolutions().then((ok)=>{ if(ok) startNewPuzzle(); });
</script>

  <!-- iOS viewport + zoom optimization -->
  <script>
    // iOS viewport-korkeus oikein (est√§√§ valkoiset nauhat ja "kuminauhaa")
    function setVH(){
      document.documentElement.style.setProperty("--vh", (window.innerHeight * 0.01) + "px");
    }
    setVH();
    window.addEventListener("resize", setVH);
    window.addEventListener("orientationchange", setVH);

    // iOS: est√§ double tap zoom (usein peleiss√§ toivottu)
    let lastTouchEnd = 0;
    document.addEventListener("touchend", (e) => {
      const now = Date.now();
      if (now - lastTouchEnd < 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });

    // Est√§ pituus-painallus kontekstivalikon avaamisen
    document.addEventListener("contextmenu", (e) => {
      e.preventDefault();
    });

    // Est√§ accidental wheel-zoom (Ctrl+scroll)
    document.addEventListener("wheel", (e) => {
      if (e.ctrlKey) e.preventDefault();
    }, { passive: false });

    // Est√§ keyboard zoom shortcuts (Ctrl/Cmd + +/-)
    document.addEventListener("keydown", (e) => {
      if ((e.ctrlKey || e.metaKey) && (e.key === "+" || e.key === "-" || e.key === "0")) {
        e.preventDefault();
      }
    }, { passive: false });

    // Est√§ accidental pinch zoom (iOS)
    let touchStartDistance = 0;
    document.addEventListener("touchstart", (e) => {
      if (e.touches.length === 2) {
        touchStartDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
      }
    }, { passive: true });

    document.addEventListener("touchmove", (e) => {
      if (e.touches.length === 2) {
        const touchDistance = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        if (Math.abs(touchDistance - touchStartDistance) > 10) {
          e.preventDefault();
        }
      }
    }, { passive: false });
  </script>

  <!-- PWA Service Worker registration -->
  <script>
    if ("serviceWorker" in navigator){
      navigator.serviceWorker.register("./sw.js", { scope: "./" }).catch(() => {});
    }
  </script>
